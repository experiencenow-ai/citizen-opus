#!/usr/bin/env python3
"""
Exploit Monitor V3 - Multi-source exploit scanner for bounty hunting
Scans RSS feeds, Twitter proxies, and blockchain alerts for fresh exploits

Run: python3 exploit_monitor_v3.py
"""

import subprocess
import json
import re
from datetime import datetime, timezone
from typing import List, Dict, Optional

# Sources to check
SOURCES = {
    "rekt_news": "https://rekt.news/rss/feed.xml",
    "google_news_defi_hack": "https://news.google.com/rss/search?q=DeFi+hack+OR+exploit&hl=en&gl=US&ceid=US:en",
    "google_news_crypto_hack": "https://news.google.com/rss/search?q=cryptocurrency+hack+2026&hl=en&gl=US&ceid=US:en",
    "blocksec": "https://twitter.com/BlockSecTeam",  # Manual check needed
    "peckshield": "https://twitter.com/paborshield",  # Manual check needed
}

# Keywords that indicate a fresh exploit
EXPLOIT_KEYWORDS = [
    "exploit", "hack", "attack", "drained", "stolen", "flash loan",
    "reentrancy", "price manipulation", "oracle", "bridge hack",
    "vulnerability", "security incident", "funds lost"
]

# Known exploits to filter out (already investigated)
KNOWN_EXPLOITS = {
    "futureswap": "2026-01-09",
    "truebit": "2026-01-07",
    "yearn": "2025-12",
    "bybit": "2025-02",
    "wazirx": "2024-07",
    "coindcx": "2025-07"
}

def fetch_rss(url: str) -> str:
    """Fetch RSS feed via curl"""
    try:
        result = subprocess.run(
            ["curl", "-s", "-L", "--max-time", "10", url],
            capture_output=True, text=True
        )
        return result.stdout
    except Exception as e:
        return f"Error: {e}"

def parse_rss_items(xml: str) -> List[Dict]:
    """Extract items from RSS XML"""
    items = []
    # Simple regex parsing for RSS items
    item_pattern = r'<item>(.*?)</item>'
    title_pattern = r'<title>(.*?)</title>'
    link_pattern = r'<link>(.*?)</link>'
    pubdate_pattern = r'<pubDate>(.*?)</pubDate>'
    
    for match in re.finditer(item_pattern, xml, re.DOTALL):
        item_xml = match.group(1)
        
        title_match = re.search(title_pattern, item_xml, re.DOTALL)
        link_match = re.search(link_pattern, item_xml)
        date_match = re.search(pubdate_pattern, item_xml)
        
        if title_match:
            title = title_match.group(1).strip()
            # Clean CDATA
            title = re.sub(r'<!\[CDATA\[(.*?)\]\]>', r'\1', title)
            
            item = {
                "title": title,
                "link": link_match.group(1) if link_match else "",
                "date": date_match.group(1) if date_match else ""
            }
            items.append(item)
    
    return items

def is_exploit_related(title: str) -> bool:
    """Check if title mentions an exploit"""
    title_lower = title.lower()
    return any(kw in title_lower for kw in EXPLOIT_KEYWORDS)

def is_known_exploit(title: str) -> bool:
    """Check if this is an already-known exploit"""
    title_lower = title.lower()
    return any(name in title_lower for name in KNOWN_EXPLOITS.keys())

def get_eth_balance(address: str, chain: str = "ethereum") -> Optional[float]:
    """Get ETH balance for an address"""
    rpc = "https://eth.llamarpc.com" if chain == "ethereum" else "https://arb1.arbitrum.io/rpc"
    
    try:
        result = subprocess.run(
            ["curl", "-s", "-X", "POST", "-H", "Content-Type: application/json",
             "--data", json.dumps({
                 "jsonrpc": "2.0",
                 "method": "eth_getBalance",
                 "params": [address, "latest"],
                 "id": 1
             }), rpc],
            capture_output=True, text=True, timeout=10
        )
        data = json.loads(result.stdout)
        balance_wei = int(data.get("result", "0x0"), 16)
        return balance_wei / 1e18
    except:
        return None

def scan_for_exploits() -> Dict:
    """Main scanning function"""
    results = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "new_exploits": [],
        "known_exploits_mentioned": [],
        "sources_checked": [],
        "errors": []
    }
    
    # Scan Google News for DeFi hacks
    for source_name, url in SOURCES.items():
        if "twitter.com" in url:
            continue  # Skip Twitter for now
            
        results["sources_checked"].append(source_name)
        xml = fetch_rss(url)
        
        if xml.startswith("Error"):
            results["errors"].append(f"{source_name}: {xml}")
            continue
        
        items = parse_rss_items(xml)
        
        for item in items[:20]:  # Check latest 20 items
            if is_exploit_related(item["title"]):
                if is_known_exploit(item["title"]):
                    results["known_exploits_mentioned"].append({
                        "title": item["title"],
                        "source": source_name
                    })
                else:
                    results["new_exploits"].append({
                        "title": item["title"],
                        "link": item["link"],
                        "date": item["date"],
                        "source": source_name
                    })
    
    return results

def check_tracked_addresses() -> Dict:
    """Check balances of tracked attacker addresses"""
    tracked = {
        "futureswap_attacker": {
            "address": "REDACTED_API_KEYA62832d95",
            "chain": "ethereum",
            "expected": 95.78,
            "status": "NOT_LAUNDERED"
        },
        "truebit_attacker": {
            "address": "REDACTED_API_KEY2FBc",
            "chain": "ethereum", 
            "expected": 0.58,
            "status": "MOSTLY_LAUNDERED"
        }
    }
    
    for name, info in tracked.items():
        balance = get_eth_balance(info["address"], info["chain"])
        if balance is not None:
            info["current_balance"] = round(balance, 4)
            info["changed"] = abs(balance - info["expected"]) > 0.1
    
    return tracked

if __name__ == "__main__":
    print("=" * 60)
    print("EXPLOIT MONITOR V3")
    print(f"Time: {datetime.now(timezone.utc).isoformat()}")
    print("=" * 60)
    
    # Scan for new exploits
    print("\n[1] Scanning news sources for new exploits...")
    results = scan_for_exploits()
    
    if results["new_exploits"]:
        print(f"\nðŸš¨ POTENTIAL NEW EXPLOITS FOUND: {len(results['new_exploits'])}")
        for exp in results["new_exploits"]:
            print(f"  - {exp['title']}")
            print(f"    Source: {exp['source']}")
    else:
        print("\nâœ“ No new exploits detected in news feeds")
    
    if results["known_exploits_mentioned"]:
        print(f"\nðŸ“° Known exploits in news: {len(results['known_exploits_mentioned'])}")
        for exp in results["known_exploits_mentioned"][:5]:
            print(f"  - {exp['title'][:60]}...")
    
    # Check tracked addresses
    print("\n[2] Checking tracked attacker addresses...")
    tracked = check_tracked_addresses()
    
    for name, info in tracked.items():
        balance = info.get("current_balance", "N/A")
        status = "ðŸš¨ MOVED!" if info.get("changed") else "âœ“ Unchanged"
        print(f"  {name}: {balance} ETH {status}")
    
    print("\n" + "=" * 60)
    
    # Save results
    output = {
        "scan_results": results,
        "tracked_addresses": tracked
    }
    
    with open("exploit_scan_latest.json", "w") as f:
        json.dump(output, f, indent=2)
    
    print("Results saved to exploit_scan_latest.json")
